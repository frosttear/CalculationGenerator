<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title data-l10n-key="grade3Semester1Title"></title>
  <script src="js/vue.min.js"></script>
  <script src="js/l10n.js" defer></script>
  <link rel="stylesheet" href="styles.css">
  <style>
    table {
      margin-bottom: 15px;
      border-collapse: collapse;
    }

    th {
      text-align: left;
      padding: 10px;
      font-weight: bold;
    }

    td {
      padding: 5px 15px;
      text-align: left;
    }

    .day-container {
      display: table;
      margin-bottom: 25px;
      page-break-inside: avoid;
    }

    @media print {
      .day-container {
        page-break-inside: avoid;
      }
    }

    .header {
      font-size: 17px;
      font-weight: bold;
      margin-top: 12px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .date-field {
      font-size: 13px;
      font-weight: normal;
      margin-left: 20px;
      display: flex;
      gap: 15px;
    }

    .section-title {
      font-size: 15px;
      font-weight: bold;
      margin-top: 12px;
      margin-bottom: 10px;
    }

    .equation {
      min-width: 150px;
      padding: 4px 5px;
    }

    .vertical-equation {
      min-width: 150px;
      padding: 10px 25px 10px 0;
      vertical-align: top;
      height: 100px;
    }

    .vertical-space {
      display: block;
      height: 70px;
      margin-top: 5px;
    }
  </style>
</head>

<body>
  <a href="../index.html" class="back-link" data-l10n-key="backToHome"></a>
  <div id="app">
    <h1 class="no-print" data-l10n-key="grade3Semester1Title"></h1>
    <div class="no-print input-area">
      <label for="dayCount" data-l10n-key="dayCount"></label>
      <input type="number" id="dayCount" v-model.number="dayCount" min="1" max="10" />

      <div class="section-title" data-l10n-key="type1Settings"></div>
      
      <label for="type1Rows" data-l10n-key="type1Rows"></label>
      <input type="number" id="type1Rows" v-model.number="type1Rows" min="1" max="10" />
      
      <label for="type1Cols" data-l10n-key="type1Cols"></label>
      <input type="number" id="type1Cols" v-model.number="type1Cols" min="1" max="10" />
      
      <div class="checkbox-group">
        <input type="checkbox" id="enableType1Constraint" v-model="enableType1LeastDigitConstraint" />
        <label for="enableType1Constraint" data-l10n-key="enableLeastDigitConstraint"></label>
      </div>
      <div class="constraint-description" data-l10n-key="leastDigitConstraintDescription"></div>

      <div class="section-title" data-l10n-key="type2Settings"></div>
      
      <label for="type2Count" data-l10n-key="type2Count"></label>
      <input type="number" id="type2Count" v-model.number="type2Count" min="1" max="20" />
      
      <label for="type2Cols" data-l10n-key="type2Cols"></label>
      <input type="number" id="type2Cols" v-model.number="type2Cols" min="1" max="10" />
      
      <button @click="generateEquations" data-l10n-key="generate" class="generate-button"></button>
    </div>
    <p v-if="errorMessage" style="color: red;">{{ errorMessage }}</p>
    
    <div v-if="practiceData.length > 0">
      <div v-for="(dayData, dayIndex) in practiceData" :key="'practice-' + dayIndex" class="day-container" :style="(dayIndex + 1) % 2 === 0 ? 'page-break-after: always;' : ''">
        <h2 class="header">
          <span data-l10n-key="practiceDay" :data-l10n-args="JSON.stringify({ day: dayIndex + 1 })"></span>
          <div class="date-field">
            <span data-l10n-key="dateLabel"></span>
            <span data-l10n-key="timeLabel"></span>
          </div>
        </h2>
        
        <!-- Type 1: Mixed Operations -->
        <h3 class="section-title" data-l10n-key="type1Title"></h3>
        <table border="0">
          <tr v-for="(row, rowIndex) in dayData.type1" :key="'type1-row-' + rowIndex">
            <td v-for="(equation, colIndex) in row" :key="'type1-eq-' + colIndex" class="equation">
              {{ equation.display }} = ____
            </td>
          </tr>
        </table>
        
        <!-- Type 2: Three-digit Addition/Subtraction -->
        <h3 class="section-title" data-l10n-key="type2Title"></h3>
        <table border="0">
          <tr v-for="(row, rowIndex) in dayData.type2" :key="'type2-row-' + rowIndex">
            <td v-for="(equation, colIndex) in row" :key="'type2-eq-' + colIndex" class="vertical-equation">
              {{ equation.number1 }} {{ equation.operator }} {{ equation.number2 }} =<br>
              <span class="vertical-space"></span>
            </td>
          </tr>
        </table>
      </div>
    </div>
    
    <!-- Answer Page -->
    <div v-if="practiceData.length > 0" style="page-break-before: always;">
      <h1><span data-l10n-key="answerPageTitle"></span></h1>
      <div v-for="(dayData, dayIndex) in practiceData" :key="'answer-' + dayIndex" class="day-container" :style="(dayIndex + 1) % 2 === 0 ? 'page-break-after: always;' : ''">
        <h2 class="header">
          <span data-l10n-key="practiceDay" :data-l10n-args="JSON.stringify({ day: dayIndex + 1 })"></span>
          <div class="date-field">
            <span data-l10n-key="dateLabel"></span>
            <span data-l10n-key="timeLabel"></span>
          </div>
        </h2>
        
        <!-- Type 1 Answers -->
        <h3 class="section-title" data-l10n-key="type1Title"></h3>
        <table border="0">
          <tr v-for="(row, rowIndex) in dayData.type1" :key="'ans-type1-row-' + rowIndex">
            <td v-for="(equation, colIndex) in row" :key="'ans-type1-eq-' + colIndex" class="equation">
              {{ equation.display }} = {{ equation.result }}
            </td>
          </tr>
        </table>
        
        <!-- Type 2 Answers -->
        <h3 class="section-title" data-l10n-key="type2Title"></h3>
        <table border="0">
          <tr v-for="(row, rowIndex) in dayData.type2" :key="'ans-type2-row-' + rowIndex">
            <td v-for="(equation, colIndex) in row" :key="'ans-type2-eq-' + colIndex" class="equation">
              {{ equation.number1 }} {{ equation.operator }} {{ equation.number2 }} = {{ equation.result }}
            </td>
          </tr>
        </table>
      </div>
    </div>
  </div>

  <script>
    new Vue({
      el: '#app',
      data: {
        dayCount: 5,
        type1Rows: 4,
        type1Cols: 5,
        enableType1LeastDigitConstraint: true,
        type2Count: 10,
        type2Cols: 4,
        practiceData: [],
        errorMessage: ''
      },
      
      methods: {
        generateEquations() {
          this.errorMessage = '';
          
          try {
            this.practiceData = [];
            
            for (let day = 0; day < this.dayCount; day++) {
              const dayData = {
                type1: this.generateType1Equations(),
                type2: this.generateType2Equations()
              };
              this.practiceData.push(dayData);
            }
            
            this.$nextTick(() => {
              window.applyTranslations();
            });
          } catch (error) {
            this.errorMessage = error.message;
            this.practiceData = [];
          }
        },
        
        // Type 1: Two operators, two-digit numbers, +/-/×/÷
        generateType1Equations() {
          const rows = [];
          const totalEquations = this.type1Rows * this.type1Cols;
          let equationCount = 0;
          
          while (equationCount < totalEquations) {
            let isValid = false;
            let attempts = 0;
            let equation;
            
            while (!isValid && attempts < 1000) {
              attempts++;
              equation = this.generateSingleType1Equation(this.enableType1LeastDigitConstraint);
              
              if (equation) {
                isValid = true;
              }
            }
            
            if (!isValid) {
              throw new Error('Unable to generate enough valid Type 1 equations. Please try reducing the count.');
            }
            
            // Add equation to the current row
            if (equationCount % this.type1Cols === 0) {
              rows.push([]);
            }
            rows[rows.length - 1].push(equation);
            equationCount++;
          }
          
          return rows;
        },
        
        generateSingleType1Equation(enableLeastDigitConstraint) {
          // One operator from +/-, one from ×/÷
          const addSubOps = ['+', '-'];
          const mulDivOps = ['×', '÷'];
          
          // Randomly decide which comes first
          const addSubFirst = Math.random() < 0.5;
          const op1 = addSubFirst ? addSubOps[Math.floor(Math.random() * 2)] : mulDivOps[Math.floor(Math.random() * 2)];
          const op2 = addSubFirst ? mulDivOps[Math.floor(Math.random() * 2)] : addSubOps[Math.floor(Math.random() * 2)];
          
          // Generate three numbers (10-99)
          let num1 = Math.floor(Math.random() * 90) + 10;
          let num2 = Math.floor(Math.random() * 90) + 10;
          let num3 = Math.floor(Math.random() * 90) + 10;
          
          // Handle division - ensure no remainder
          if (op1 === '÷') {
            // num1 / num2: make sure num1 is divisible by num2
            num2 = Math.floor(Math.random() * 9) + 2; // 2-10
            num1 = num2 * (Math.floor(Math.random() * 9) + 2); // Multiple of num2
          }
          
          if (op2 === '÷') {
            // Calculate intermediate result first
            let intermediate = this.calculate(num1, num2, op1);
            if (intermediate === null) return null;
            
            // Make sure intermediate is divisible by num3
            num3 = Math.floor(Math.random() * 9) + 2;
            // Adjust num2 so that intermediate result is divisible by num3
            const targetIntermediate = num3 * (Math.floor(Math.random() * 9) + 2);
            
            // Recalculate to get proper values
            if (op1 === '+') {
              num2 = Math.max(10, targetIntermediate - num1);
            } else if (op1 === '-') {
              num2 = Math.max(1, num1 - targetIntermediate);
            } else if (op1 === '×') {
              if (num1 > 0 && targetIntermediate % num1 === 0) {
                num2 = Math.min(99, Math.max(10, targetIntermediate / num1));
              } else {
                num2 = Math.floor(Math.random() * 9) + 2;
              }
            } else if (op1 === '÷') {
              num1 = targetIntermediate * num2;
            }
          }
          
          // Handle multiplication - ensure product < 100
          if (op1 === '×') {
            num1 = Math.floor(Math.random() * 9) + 2;
            const maxNum2 = Math.min(9, Math.floor(99 / num1));
            
            // Decide if we want to generate two-digit or one-digit num2
            const canBeTwoDigit = maxNum2 >= 10;
            const generateTwoDigit = canBeTwoDigit && Math.random() < 0.5; // 50% chance if possible
            
            if (generateTwoDigit && enableLeastDigitConstraint) {
              // Generate two-digit num2 with constraint: ones digit × num1 < 10
              const maxOnesDigit = Math.floor(10 / num1) - 1;
              
              if (maxOnesDigit >= 0) {
                // Generate tens digit (1-9) and valid ones digit (0-maxOnesDigit)
                const tensDigit = Math.floor(Math.random() * Math.min(9, Math.floor(maxNum2 / 10))) + 1;
                const onesDigit = Math.floor(Math.random() * (maxOnesDigit + 1));
                num2 = tensDigit * 10 + onesDigit;
                
                // Ensure result < 100
                if (num1 * num2 >= 100) {
                  num2 = Math.floor(Math.random() * (maxOnesDigit + 1)) + 10; // Fallback to smaller two-digit
                }
              } else {
                // Can't make two-digit with constraint, use single-digit instead
                num2 = Math.floor(Math.random() * Math.min(9, maxNum2)) + 2;
              }
            } else if (generateTwoDigit && !enableLeastDigitConstraint) {
              // Generate two-digit without constraint
              num2 = Math.floor(Math.random() * (maxNum2 - 9)) + 10;
            } else {
              // Generate one-digit num2 (no constraint needed for one-digit × one-digit)
              num2 = Math.floor(Math.random() * Math.min(9, maxNum2)) + 2;
            }
          }
          
          if (op2 === '×') {
            let intermediate = this.calculate(num1, num2, op1);
            if (intermediate === null || intermediate <= 0) return null;
            
            const maxNum3 = Math.min(9, Math.floor(99 / Math.max(1, intermediate)));
            
            if (enableLeastDigitConstraint && (op1 === '+' || op1 === '-')) {
              // num2 × num3 will be calculated first due to order of operations
              // Constraint only applies to two-digit × one-digit patterns
              
              if (num2 >= 10) {
                // num2 is two-digit, need to generate valid num3 or regenerate num2
                const leastDigit2 = num2 % 10;
                
                if (leastDigit2 > 0) {
                  const maxValidNum3 = Math.min(maxNum3, Math.floor(10 / leastDigit2) - 1);
                  
                  if (maxValidNum3 >= 2) {
                    // Can generate valid num3
                    num3 = Math.floor(Math.random() * (maxValidNum3 - 1)) + 2;
                  } else {
                    // Can't generate valid num3, need to regenerate num2 with constraint
                    // ones digit of num2 must allow at least num3 = 2
                    // leastDigit2 * 2 < 10, so leastDigit2 <= 4
                    const maxLeastDigit = 4;
                    const tensDigit2 = Math.floor(Math.random() * 9) + 1; // 1-9
                    const onesDigit2 = Math.floor(Math.random() * (maxLeastDigit + 1)); // 0-4
                    num2 = tensDigit2 * 10 + onesDigit2;
                    
                    // Recalculate intermediate and maxNum3
                    intermediate = this.calculate(num1, num2, op1);
                    if (intermediate === null || intermediate <= 0) return null;
                    
                    const newMaxNum3 = Math.min(9, Math.floor(99 / Math.max(1, intermediate)));
                    const newLeastDigit2 = num2 % 10;
                    const newMaxValidNum3 = newLeastDigit2 > 0 ? Math.min(newMaxNum3, Math.floor(10 / newLeastDigit2) - 1) : newMaxNum3;
                    
                    num3 = Math.floor(Math.random() * Math.min(newMaxValidNum3, 8)) + 2;
                  }
                } else {
                  // leastDigit2 is 0 (e.g., 20, 30), any num3 works
                  num3 = Math.floor(Math.random() * Math.min(9, maxNum3)) + 2;
                }
              } else {
                // num2 is single-digit
                const canBeTwoDigit = maxNum3 >= 10;
                const generateTwoDigit = canBeTwoDigit && Math.random() < 0.5; // 50% chance
                
                if (generateTwoDigit) {
                  // Generate two-digit num3 with constraint: ones digit × num2 < 10
                  const maxOnesDigit = Math.floor(10 / num2) - 1;
                  
                  if (maxOnesDigit >= 0) {
                    const tensDigit = Math.floor(Math.random() * Math.min(9, Math.floor(maxNum3 / 10))) + 1;
                    const onesDigit = Math.floor(Math.random() * (maxOnesDigit + 1));
                    num3 = tensDigit * 10 + onesDigit;
                  } else {
                    // Can't make two-digit with constraint, use single-digit
                    num3 = Math.floor(Math.random() * Math.min(9, maxNum3)) + 2;
                  }
                } else {
                  // Generate one-digit num3 (no constraint for one-digit × one-digit)
                  num3 = Math.floor(Math.random() * Math.min(9, maxNum3)) + 2;
                }
              }
            } else {
              // No constraint or multiplication happens after addition/subtraction
              num3 = Math.floor(Math.random() * maxNum3) + 2;
            }
          }
          
          // Calculate intermediate result
          const intermediate = this.calculate(num1, num2, op1);
          if (intermediate === null || intermediate < 0) return null;
          
          // Calculate final result based on order of operations
          let result;
          if ((op1 === '×' || op1 === '÷') && (op2 === '+' || op2 === '-')) {
            // Calculate op1 first, then apply op2
            result = this.calculate(intermediate, num3, op2);
          } else if ((op1 === '+' || op1 === '-') && (op2 === '×' || op2 === '÷')) {
            // Calculate op2 first (num2 op2 num3), then apply op1
            const part2 = this.calculate(num2, num3, op2);
            if (part2 === null || part2 < 0) return null;
            result = this.calculate(num1, part2, op1);
          } else {
            // Same precedence, calculate left to right
            result = this.calculate(intermediate, num3, op2);
          }
          
          if (result === null || !Number.isInteger(result) || result < 0) return null;
          
          // Format display based on order of operations
          let display;
          if ((op1 === '+' || op1 === '-') && (op2 === '×' || op2 === '÷')) {
            // Need parentheses or reorder display
            display = `${num1} ${op1} ${num2} ${op2} ${num3}`;
          } else {
            display = `${num1} ${op1} ${num2} ${op2} ${num3}`;
          }
          
          return {
            number1: num1,
            number2: num2,
            number3: num3,
            operator1: op1,
            operator2: op2,
            display: display,
            result: result
          };
        },
        
        // Type 2: Three-digit addition/subtraction
        generateType2Equations() {
          const rows = [];
          let equationCount = 0;
          
          while (equationCount < this.type2Count) {
            const operator = Math.random() < 0.5 ? '+' : '-';
            let num1, num2, result;
            let isValid = false;
            let attempts = 0;
            
            while (!isValid && attempts < 1000) {
              attempts++;
              
              if (operator === '+') {
                // For addition: num1 + num2 <= 1000
                num1 = Math.floor(Math.random() * 900) + 100; // 100-999
                num2 = Math.floor(Math.random() * 900) + 100; // 100-999
                result = num1 + num2;
                
                // Check if result <= 1000
                if (result <= 1000) {
                  isValid = true;
                }
              } else {
                // For subtraction: allow num1 to be 100-1000, num2 to be 100-999
                // Special case: allow 1000 as minuend (e.g., 1000 - 366)
                const allowThousand = Math.random() < 0.2; // 20% chance for 1000
                if (allowThousand) {
                  num1 = 1000;
                  num2 = Math.floor(Math.random() * 900) + 100; // 100-999
                } else {
                  num1 = Math.floor(Math.random() * 900) + 100; // 100-999
                  num2 = Math.floor(Math.random() * 900) + 100; // 100-999
                }
                
                // Ensure num1 >= num2
                if (num1 < num2) {
                  [num1, num2] = [num2, num1];
                }
                
                result = num1 - num2;
                isValid = true;
              }
            }
            
            if (!isValid) {
              throw new Error('Unable to generate valid Type 2 equations with result <= 1000');
            }
            
            const equation = {
              number1: num1,
              number2: num2,
              operator: operator,
              result: result
            };
            
            // Add equation to the current row
            if (equationCount % this.type2Cols === 0) {
              rows.push([]);
            }
            rows[rows.length - 1].push(equation);
            equationCount++;
          }
          
          return rows;
        },
        
        calculate(a, b, op) {
          switch (op) {
            case '+':
              return a + b;
            case '-':
              return a - b;
            case '×':
              return a * b;
            case '÷':
              return b !== 0 && a % b === 0 ? a / b : null;
            default:
              return null;
          }
        }
      }
    });
  </script>

</body>

</html>
